<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Play backgammon against a computer opponent">
    <meta name="theme-color" content="#8b4513">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Backgammon">
    <link rel="manifest" href="./backgammon.manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' fill='%238b4513'/%3E%3Crect x='10' y='10' width='80' height='80' rx='4' fill='%23d2691e'/%3E%3Cpath d='M20 20 L30 50 L20 80 M40 20 L30 50 L40 80 M60 20 L70 50 L60 80 M80 20 L70 50 L80 80' stroke='%23654321' stroke-width='2' fill='none'/%3E%3Ccircle cx='35' cy='35' r='6' fill='white'/%3E%3Ccircle cx='65' cy='65' r='6' fill='%23333'/%3E%3C/svg%3E">
    <title>Backgammon</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c1810 0%, #4a2c1a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #fff;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .game-container {
            background: #8b4513;
            border: 8px solid #654321;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            max-width: 900px;
            width: 100%;
        }

        .board {
            background: linear-gradient(90deg, #d2691e 0%, #cd853f 50%, #d2691e 100%);
            border: 4px solid #654321;
            border-radius: 8px;
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(13, 1fr);
            gap: 0;
            position: relative;
        }

        .point {
            height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }

        .point.top {
            flex-direction: column;
        }

        .point.bottom {
            flex-direction: column-reverse;
        }

        .point::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 25px solid transparent;
            border-right: 25px solid transparent;
            position: absolute;
        }

        .point.top::before {
            border-top: 80px solid;
            top: 0;
        }

        .point.bottom::before {
            border-bottom: 80px solid;
            bottom: 0;
        }

        .point:nth-child(odd)::before {
            border-top-color: #8b4513;
            border-bottom-color: #8b4513;
        }

        .point:nth-child(even)::before {
            border-top-color: #f5deb3;
            border-bottom-color: #f5deb3;
        }

        .point.highlight {
            background: rgba(255, 215, 0, 0.3);
        }

        .point.selected {
            background: rgba(255, 215, 0, 0.5);
        }

        .bar {
            background: #654321;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 10px 5px;
        }

        .checker {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 3px solid;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            z-index: 10;
        }

        .checker.moving {
            animation: moveChecker 0.5s ease-in-out;
            z-index: 100;
        }

        @keyframes moveChecker {
            0% {
                transform: scale(1);
            }
            25% {
                transform: scale(1.3) translateY(-30px);
            }
            50% {
                transform: scale(1.3) translateY(-40px);
            }
            75% {
                transform: scale(1.3) translateY(-30px);
            }
            100% {
                transform: scale(1);
            }
        }

        .checker.white {
            background: radial-gradient(circle at 30% 30%, #fff, #e0e0e0);
            border-color: #999;
        }

        .checker.black {
            background: radial-gradient(circle at 30% 30%, #333, #000);
            border-color: #000;
        }

        .checker:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0,0,0,0.5);
        }

        .checker.selectable {
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
        }

        .info-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        .player-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .player-name {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .player-info.active {
            color: #ffd700;
        }

        .dice-container {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .die {
            width: 60px;
            height: 60px;
            background: white;
            border: 2px solid #333;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: bold;
            color: #000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .die.used {
            opacity: 0.3;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .btn-primary {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .message {
            text-align: center;
            font-size: 1.2rem;
            padding: 15px;
            background: rgba(255, 215, 0, 0.2);
            border-radius: 8px;
            margin-top: 15px;
            font-weight: bold;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .message.win {
            background: rgba(76, 175, 80, 0.3);
            font-size: 1.5rem;
            animation: pulse 0.5s ease-in-out 3;
        }

        .message.lose {
            background: rgba(244, 67, 54, 0.3);
            font-size: 1.5rem;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .off-board {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 10px;
            min-height: 100px;
        }

        .checkers-stack {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: -30px;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .board {
                padding: 10px;
            }

            .point {
                height: 150px;
            }

            .point::before {
                border-left-width: 15px;
                border-right-width: 15px;
                border-top-width: 50px;
                border-bottom-width: 50px;
            }

            .checker {
                width: 30px;
                height: 30px;
            }

            .die {
                width: 45px;
                height: 45px;
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <h1>Backgammon</h1>

    <div class="game-container">
        <div class="board" id="board">
            <!-- Points 12-7 (top) -->
            <div class="point top" data-point="12"></div>
            <div class="point top" data-point="11"></div>
            <div class="point top" data-point="10"></div>
            <div class="point top" data-point="9"></div>
            <div class="point top" data-point="8"></div>
            <div class="point top" data-point="7"></div>

            <!-- Bar -->
            <div class="bar" id="bar">
                <div id="bar-black"></div>
                <div id="bar-white"></div>
            </div>

            <!-- Points 6-1 (top) -->
            <div class="point top" data-point="6"></div>
            <div class="point top" data-point="5"></div>
            <div class="point top" data-point="4"></div>
            <div class="point top" data-point="3"></div>
            <div class="point top" data-point="2"></div>
            <div class="point top" data-point="1"></div>

            <!-- Points 13-18 (bottom) -->
            <div class="point bottom" data-point="13"></div>
            <div class="point bottom" data-point="14"></div>
            <div class="point bottom" data-point="15"></div>
            <div class="point bottom" data-point="16"></div>
            <div class="point bottom" data-point="17"></div>
            <div class="point bottom" data-point="18"></div>

            <!-- Bar (bottom side, visual only) -->
            <div class="bar"></div>

            <!-- Points 19-24 (bottom) -->
            <div class="point bottom" data-point="19"></div>
            <div class="point bottom" data-point="20"></div>
            <div class="point bottom" data-point="21"></div>
            <div class="point bottom" data-point="22"></div>
            <div class="point bottom" data-point="23"></div>
            <div class="point bottom" data-point="24"></div>
        </div>

        <div class="info-panel">
            <div class="player-info" id="player-info">
                <div class="player-name">You (White)</div>
                <div>Borne off: <span id="white-off">0</span></div>
            </div>

            <div class="dice-container">
                <div id="dice-display"></div>
            </div>

            <div class="player-info" id="computer-info">
                <div class="player-name">Computer (Black)</div>
                <div>Borne off: <span id="black-off">0</span></div>
            </div>
        </div>

        <div class="controls">
            <button class="btn-primary" id="roll-btn" onclick="rollDice()">Roll Dice</button>
            <button class="btn-secondary" id="end-turn-btn" onclick="endTurn()" disabled>End Turn</button>
            <button class="btn-secondary" onclick="newGame()">New Game</button>
        </div>

        <div class="message" id="message">Welcome! Click "Roll Dice" to start</div>

        <div style="margin-top: 15px; padding: 15px; background: rgba(0,0,0,0.3); border-radius: 8px; font-size: 0.9rem; line-height: 1.6;">
            <strong>How to Play:</strong><br>
            â€¢ Click a checker to select it, then click the highlighted destination<br>
            â€¢ <strong>To bear off:</strong> Get all your checkers to points 19-24 (home board), then double-click a checker to remove it<br>
            â€¢ First player to bear off all 15 checkers wins!
        </div>
    </div>

    <script>
        // Game state
        const board = Array(25).fill(null).map(() => []); // 0 is bar, 1-24 are points, 25 is off
        let whiteOff = 0;
        let blackOff = 0;
        let currentPlayer = 'white'; // 'white' or 'black'
        let dice = [];
        let usedDice = [];
        let selectedPoint = null;

        // Initialize game
        function initGame() {
            // Reset board
            for (let i = 0; i <= 25; i++) {
                board[i] = [];
            }

            // Setup starting position (standard backgammon)
            // White moves 1->24, Black moves 24->1
            board[1] = ['white', 'white'];
            board[12] = ['white', 'white', 'white', 'white', 'white'];
            board[17] = ['white', 'white', 'white'];
            board[19] = ['white', 'white', 'white', 'white', 'white'];

            board[24] = ['black', 'black'];
            board[13] = ['black', 'black', 'black', 'black', 'black'];
            board[8] = ['black', 'black', 'black'];
            board[6] = ['black', 'black', 'black', 'black', 'black'];

            whiteOff = 0;
            blackOff = 0;
            currentPlayer = 'white';
            dice = [];
            usedDice = [];
            selectedPoint = null;

            renderBoard();
            updateMessage("Click 'Roll Dice' to start your turn");
            document.getElementById('roll-btn').disabled = false;
            document.getElementById('end-turn-btn').disabled = true;
        }

        function renderBoard() {
            // Clear all points
            document.querySelectorAll('.point').forEach(point => {
                point.innerHTML = '';
                point.classList.remove('highlight', 'selected');
            });

            // Render checkers on board
            for (let i = 1; i <= 24; i++) {
                const point = document.querySelector(`.point[data-point="${i}"]`);
                const checkers = board[i];

                checkers.forEach((color, index) => {
                    const checker = createChecker(color, i);
                    point.appendChild(checker);
                });
            }

            // Render bar
            const barWhite = document.getElementById('bar-white');
            const barBlack = document.getElementById('bar-black');
            barWhite.innerHTML = '';
            barBlack.innerHTML = '';

            board[0].forEach(color => {
                const checker = createChecker(color, 0);
                if (color === 'white') {
                    barWhite.appendChild(checker);
                } else {
                    barBlack.appendChild(checker);
                }
            });

            // Update off board counts
            document.getElementById('white-off').textContent = whiteOff;
            document.getElementById('black-off').textContent = blackOff;

            // Update player indicators
            document.getElementById('player-info').classList.toggle('active', currentPlayer === 'white');
            document.getElementById('computer-info').classList.toggle('active', currentPlayer === 'black');
        }

        function createChecker(color, point) {
            const checker = document.createElement('div');
            checker.className = `checker ${color}`;
            checker.dataset.point = point;
            checker.dataset.color = color;

            checker.onclick = () => handleCheckerClick(point, color);

            return checker;
        }

        function handleCheckerClick(point, color) {
            if (currentPlayer !== 'white' || dice.length === 0) return;
            if (color !== 'white') return;

            // If there are checkers on the bar, must move them first
            const whiteOnBar = board[0].filter(c => c === 'white').length;
            if (whiteOnBar > 0 && point !== 0) return;

            if (selectedPoint === point) {
                // Double-click: try to bear off if possible
                if (canBearOff('white') && point >= 19 && point <= 24) {
                    attemptMove(point, 25);
                    return;
                }
                // Otherwise deselect
                selectedPoint = null;
                renderBoard();
                renderDice();
            } else {
                // Select this checker
                selectedPoint = point;
                renderBoard();
                highlightValidMoves();
            }
        }

        function highlightValidMoves() {
            if (selectedPoint === null) return;

            // Check each unused die by index
            for (let i = 0; i < dice.length; i++) {
                if (usedDice.includes(i)) continue;

                const die = dice[i];
                const targetPoint = getTargetPoint(selectedPoint, die, 'white');
                if (targetPoint !== null && isValidMove(selectedPoint, targetPoint, 'white')) {
                    if (targetPoint === 25) {
                        // Bearing off - can show message
                        updateMessage("Double-click this checker to bear it off!");
                    } else {
                        const pointEl = document.querySelector(`.point[data-point="${targetPoint}"]`);
                        if (pointEl) pointEl.classList.add('highlight');
                    }
                }
            }

            const pointEl = document.querySelector(`.point[data-point="${selectedPoint}"]`);
            if (pointEl) pointEl.classList.add('selected');
        }

        document.querySelectorAll('.point').forEach(point => {
            point.addEventListener('click', (e) => {
                if (e.target.classList.contains('checker')) return;

                const targetPoint = parseInt(point.dataset.point);
                if (selectedPoint !== null) {
                    attemptMove(selectedPoint, targetPoint);
                }
            });
        });

        function attemptMove(from, to) {
            // Try each unused die
            for (let i = 0; i < dice.length; i++) {
                if (usedDice.includes(i)) continue;

                const die = dice[i];
                const targetPoint = getTargetPoint(from, die, 'white');

                if (targetPoint === to && isValidMove(from, to, 'white')) {
                    makeMove(from, to, 'white');
                    usedDice.push(i);
                    selectedPoint = null;

                    // Wait for animation before updating dice and checking for turn end
                    setTimeout(() => {
                        renderDice();
                        if (usedDice.length === dice.length || !hasValidMoves('white')) {
                            setTimeout(() => endTurn(), 500);
                        }
                    }, 450);
                    return;
                }
            }

            // Special case for bearing off with higher die
            if (to === 25 && canBearOff('white')) {
                for (let i = 0; i < dice.length; i++) {
                    if (usedDice.includes(i)) continue;

                    const die = dice[i];
                    const exactTarget = from + die;

                    // Can bear off if exact or if no checkers behind this one
                    if (exactTarget >= 25) {
                        let canUseHigherDie = exactTarget > 25;
                        if (canUseHigherDie) {
                            // Check if this is the furthest back checker
                            let hasCheckerBehind = false;
                            for (let p = 1; p < from; p++) {
                                if (board[p].some(c => c === 'white')) {
                                    hasCheckerBehind = true;
                                    break;
                                }
                            }
                            if (!hasCheckerBehind) {
                                makeMove(from, 25, 'white');
                                usedDice.push(i);
                                selectedPoint = null;

                                // Wait for animation before updating dice and checking for turn end
                                setTimeout(() => {
                                    renderDice();
                                    if (usedDice.length === dice.length || !hasValidMoves('white')) {
                                        setTimeout(() => endTurn(), 500);
                                    }
                                }, 450);
                                return;
                            }
                        }
                    }
                }
            }
        }

        function getTargetPoint(from, die, player) {
            if (player === 'white') {
                if (from === 0) {
                    // Entering from bar
                    return 25 - die;
                } else {
                    const target = from + die;
                    if (target > 24) {
                        // Check if can bear off
                        if (canBearOff(player)) {
                            return 25;
                        }
                        return null;
                    }
                    return target;
                }
            } else { // black
                if (from === 0) {
                    return die;
                } else {
                    const target = from - die;
                    if (target < 1) {
                        if (canBearOff(player)) {
                            return 25;
                        }
                        return null;
                    }
                    return target;
                }
            }
        }

        function isValidMove(from, to, player) {
            if (to === 25) {
                return canBearOff(player);
            }

            const destCheckers = board[to];
            if (destCheckers.length === 0) return true;

            const topChecker = destCheckers[destCheckers.length - 1];
            if (topChecker === player) return true;

            // Can hit opponent if only one checker
            if (destCheckers.length === 1 && topChecker !== player) return true;

            return false;
        }

        function canBearOff(player) {
            if (player === 'white') {
                // Check if all checkers are in home board (19-24)
                for (let i = 1; i <= 18; i++) {
                    if (board[i].some(c => c === 'white')) return false;
                }
                if (board[0].some(c => c === 'white')) return false;
            } else {
                // Check if all checkers are in home board (1-6)
                for (let i = 7; i <= 24; i++) {
                    if (board[i].some(c => c === 'black')) return false;
                }
                if (board[0].some(c => c === 'black')) return false;
            }
            return true;
        }

        function makeMove(from, to, player, animated = true) {
            // Find the checker element to animate
            let checkerElement = null;
            if (animated && from !== 0) {
                const pointEl = document.querySelector(`.point[data-point="${from}"]`);
                if (pointEl) {
                    const checkers = pointEl.querySelectorAll(`.checker.${player}`);
                    if (checkers.length > 0) {
                        checkerElement = checkers[checkers.length - 1];
                    }
                }
            } else if (animated && from === 0) {
                // From bar
                const barEl = player === 'white' ? document.getElementById('bar-white') : document.getElementById('bar-black');
                if (barEl) {
                    const checkers = barEl.querySelectorAll(`.checker.${player}`);
                    if (checkers.length > 0) {
                        checkerElement = checkers[checkers.length - 1];
                    }
                }
            }

            // Add animation class
            if (checkerElement) {
                checkerElement.classList.add('moving');
            }

            // Wait for animation, then update board state
            setTimeout(() => {
                // Remove checker from source
                const checkerIndex = board[from].lastIndexOf(player);
                board[from].splice(checkerIndex, 1);

                if (to === 25) {
                    // Bearing off
                    if (player === 'white') {
                        whiteOff++;
                    } else {
                        blackOff++;
                    }
                } else {
                    // Check for hit
                    if (board[to].length === 1 && board[to][0] !== player) {
                        const hitChecker = board[to][0];
                        board[to] = [];
                        board[0].push(hitChecker); // Send to bar
                    }

                    // Place checker
                    board[to].push(player);
                }

                // Re-render board
                renderBoard();

                // Check for win
                if (whiteOff === 15) {
                    const msgEl = document.getElementById('message');
                    msgEl.textContent = "ðŸŽ‰ Congratulations! You won! ðŸŽ‰";
                    msgEl.className = "message win";
                    endGame();
                } else if (blackOff === 15) {
                    const msgEl = document.getElementById('message');
                    msgEl.textContent = "Computer wins!";
                    msgEl.className = "message lose";
                    endGame();
                }
            }, animated ? 400 : 0);
        }

        function hasValidMoves(player) {
            const availableDice = dice.filter((_, i) => !usedDice.includes(i));
            if (availableDice.length === 0) return false;

            // Check bar first
            if (board[0].some(c => c === player)) {
                for (const die of availableDice) {
                    const target = getTargetPoint(0, die, player);
                    if (target && isValidMove(0, target, player)) {
                        return true;
                    }
                }
                return false;
            }

            // Check all points
            for (let i = 1; i <= 24; i++) {
                if (board[i].some(c => c === player)) {
                    for (const die of availableDice) {
                        const target = getTargetPoint(i, die, player);
                        if (target && isValidMove(i, target, player)) {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        function rollDice() {
            dice = [
                Math.floor(Math.random() * 6) + 1,
                Math.floor(Math.random() * 6) + 1
            ];

            // Doubles: use all four dice
            if (dice[0] === dice[1]) {
                dice = [dice[0], dice[0], dice[0], dice[0]];
            }

            usedDice = [];
            renderDice();

            document.getElementById('roll-btn').disabled = true;
            document.getElementById('end-turn-btn').disabled = false;

            if (!hasValidMoves('white')) {
                updateMessage("No valid moves! Turn ends automatically.");
                setTimeout(() => endTurn(), 1500);
            } else {
                if (canBearOff('white')) {
                    updateMessage("You can bear off! Double-click checkers in your home board (19-24) to remove them.");
                } else {
                    updateMessage("Make your moves! Click a checker, then click its destination.");
                }
            }
        }

        function renderDice() {
            const diceDisplay = document.getElementById('dice-display');
            diceDisplay.innerHTML = '';

            dice.forEach((die, index) => {
                const dieEl = document.createElement('div');
                dieEl.className = 'die';
                if (usedDice.includes(index)) {
                    dieEl.classList.add('used');
                }
                dieEl.textContent = die;
                diceDisplay.appendChild(dieEl);
            });
        }

        function endTurn() {
            selectedPoint = null;
            dice = [];
            usedDice = [];
            renderDice();
            renderBoard();

            currentPlayer = 'black';
            document.getElementById('roll-btn').disabled = true;
            document.getElementById('end-turn-btn').disabled = true;
            updateMessage("Computer's turn...");

            setTimeout(() => computerTurn(), 1000);
        }

        function computerTurn() {
            // Roll dice for computer
            dice = [
                Math.floor(Math.random() * 6) + 1,
                Math.floor(Math.random() * 6) + 1
            ];

            if (dice[0] === dice[1]) {
                dice = [dice[0], dice[0], dice[0], dice[0]];
            }

            usedDice = [];
            renderDice();

            if (!hasValidMoves('black')) {
                updateMessage("Computer has no valid moves!");
                setTimeout(() => {
                    currentPlayer = 'white';
                    document.getElementById('roll-btn').disabled = false;
                    renderBoard();
                    updateMessage("Your turn! Roll the dice.");
                }, 1500);
                return;
            }

            // Simple AI: make random valid moves
            makeComputerMoves();
        }

        function makeComputerMoves() {
            const moves = [];

            function makeNextMove(index) {
                if (usedDice.length >= dice.length) {
                    // All dice used, end computer turn
                    setTimeout(() => {
                        currentPlayer = 'white';
                        document.getElementById('roll-btn').disabled = false;
                        updateMessage("Your turn! Roll the dice.");
                    }, 800);
                    return;
                }

                const validMoves = [];

                // Check bar first
                if (board[0].some(c => c === 'black')) {
                    for (let i = 0; i < dice.length; i++) {
                        if (usedDice.includes(i)) continue;
                        const die = dice[i];
                        const target = getTargetPoint(0, die, 'black');
                        if (target && isValidMove(0, target, 'black')) {
                            validMoves.push({ from: 0, to: target, dieIndex: i });
                        }
                    }
                } else {
                    // Check all points
                    for (let point = 1; point <= 24; point++) {
                        if (board[point].some(c => c === 'black')) {
                            for (let i = 0; i < dice.length; i++) {
                                if (usedDice.includes(i)) continue;
                                const die = dice[i];
                                const target = getTargetPoint(point, die, 'black');
                                if (target && isValidMove(point, target, 'black')) {
                                    validMoves.push({ from: point, to: target, dieIndex: i });
                                }
                            }
                        }
                    }
                }

                if (validMoves.length === 0) {
                    // No valid moves left, end computer turn
                    setTimeout(() => {
                        currentPlayer = 'white';
                        document.getElementById('roll-btn').disabled = false;
                        updateMessage("Your turn! Roll the dice.");
                    }, 800);
                    return;
                }

                // Pick a random valid move
                const move = validMoves[Math.floor(Math.random() * validMoves.length)];
                makeMove(move.from, move.to, 'black');
                usedDice.push(move.dieIndex);

                // Wait for animation, then make next move
                setTimeout(() => {
                    renderDice();
                    makeNextMove(index + 1);
                }, 600);
            }

            // Start making moves
            makeNextMove(0);
        }

        function updateMessage(msg) {
            const msgEl = document.getElementById('message');
            msgEl.textContent = msg;
            msgEl.className = 'message'; // Reset to default styling
        }

        function endGame() {
            document.getElementById('roll-btn').disabled = true;
            document.getElementById('end-turn-btn').disabled = true;
            dice = [];
            usedDice = [];
            renderDice();

            // Show prominent game over message
            setTimeout(() => {
                const winner = whiteOff === 15 ? 'You' : 'Computer';
                const msg = whiteOff === 15
                    ? 'ðŸŽ‰ Congratulations! You won! ðŸŽ‰\n\nClick "New Game" to play again.'
                    : 'ðŸ˜¢ Computer wins!\n\nClick "New Game" to try again.';

                if (confirm(msg + '\n\nStart a new game now?')) {
                    newGame();
                }
            }, 500);
        }

        function newGame() {
            initGame();
        }

        // Initialize on load
        window.onload = () => {
            initGame();
        };

        // Register service worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./backgammon-sw.js')
                    .then((registration) => {
                        console.log('ServiceWorker registration successful:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('ServiceWorker registration failed:', error);
                    });
            });
        }
    </script>
</body>
</html>
