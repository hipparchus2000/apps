<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mahjong Solitaire</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --board-bg: #27ae60;
            --tile-width: 50px;
            --tile-height: 70px;
            --tile-depth: 6px;
            --tile-color: #ecf0f1;
            --tile-shadow: #bdc3c7;
            --tile-border: #95a5a6;
            --accent-color: #e74c3c;
            --text-color: #ecf0f1;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        header {
            width: 100%;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            z-index: 100;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            letter-spacing: 1px;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            background-color: var(--tile-color);
            border: none;
            border-radius: 4px;
            padding: 8px 16px;
            font-family: inherit;
            font-weight: bold;
            color: #2c3e50;
            cursor: pointer;
            box-shadow: 0 4px 0 #bdc3c7;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #bdc3c7;
        }

        button:hover {
            background-color: #fff;
        }

        .status-bar {
            display: flex;
            gap: 20px;
            font-size: 1rem;
        }

        #game-board {
            position: relative;
            width: 100%;
            flex-grow: 1;
            background-color: var(--board-bg);
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            perspective: 1000px;
        }

        .board-container {
            position: relative;
            /* Dimensions will be set by JS based on layout */
            transform-style: preserve-3d;
            transition: transform 0.3s;
        }

        .tile {
            position: absolute;
            width: var(--tile-width);
            height: var(--tile-height);
            background-color: var(--tile-color);
            border: 1px solid var(--tile-border);
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem;
            cursor: pointer;
            box-shadow:
                2px 2px 0 var(--tile-shadow),
                3px 3px 0 rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, background-color 0.2s, box-shadow 0.2s;
            z-index: 1;
        }

        /* 3D layering effect */
        .tile::before {
            content: '';
            position: absolute;
            left: -6px;
            top: 6px;
            width: 6px;
            height: 100%;
            background: #95a5a6;
            transform: skewY(-45deg);
            transform-origin: right top;
            border-left: 1px solid #7f8c8d;
        }

        .tile::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: -6px;
            width: 100%;
            height: 6px;
            background: #bdc3c7;
            transform: skewX(-45deg);
            transform-origin: right top;
            border-bottom: 1px solid #7f8c8d;
        }

        .tile.selected {
            background-color: #81ecec;
            transform: translate(-2px, -2px);
            box-shadow:
                4px 4px 0 var(--tile-shadow),
                5px 5px 0 rgba(0, 0, 0, 0.2);
            border-color: #00cec9;
            z-index: 100 !important;
            /* Bring selected to top visually */
        }

        .tile.hint {
            animation: pulse 1.5s infinite;
            background-color: #ffeaa7;
        }

        .tile.blocked {
            color: rgba(0, 0, 0, 0.3);
            cursor: default;
            background-color: #dcdde1;
        }

        .tile.blocked::before {
            background: #7f8c8d;
        }

        .tile.blocked::after {
            background: #95a5a6;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 234, 167, 0.7);
            }

            70% {
                transform: scale(1.05);
                box-shadow: 0 0 0 10px rgba(255, 234, 167, 0);
            }

            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 234, 167, 0);
            }
        }

        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #message-overlay.visible {
            visibility: visible;
            opacity: 1;
        }

        .message-box {
            background: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            color: #2c3e50;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }

        .message-box h2 {
            margin-top: 0;
        }

        .hidden {
            display: none;
        }

        /* Suit Colors */
        .suit-dots {
            color: #2980b9;
        }

        .suit-bams {
            color: #27ae60;
        }

        .suit-chars {
            color: #c0392b;
        }

        .suit-winds {
            color: #2c3e50;
        }

        .suit-dragons {
            color: #e74c3c;
        }

        /* Red dragon */
        .suit-dragons[data-value="Green"] {
            color: #27ae60;
        }

        .suit-dragons[data-value="White"] {
            color: #2980b9;
        }

        .suit-flowers {
            color: #8e44ad;
        }

        .suit-seasons {
            color: #d35400;
        }
    </style>
</head>

<body>

    <header>
        <h1>Mahjong</h1>
        <div class="status-bar">
            <span id="score-display">Pairs: 0</span>
            <span id="remaining-display">Tiles: 144</span>
        </div>
        <div class="controls">
            <button id="btn-undo">Undo</button>
            <button id="btn-hint">Hint</button>
            <button id="btn-new-game">New Game</button>
        </div>
    </header>

    <div id="game-board">
        <div id="board-container" class="board-container">
            <!-- Tiles will be injected here -->
        </div>
    </div>

    <div id="message-overlay">
        <div class="message-box">
            <h2 id="message-title">Game Over</h2>
            <p id="message-text">No more moves!</p>
            <button onclick="game.newGame()">Play Again</button>
        </div>
    </div>

    <script>
        class MahjongGame {
            constructor() {
                this.tiles = [];
                this.selectedTile = null;
                this.history = [];
                this.tileTypes = this.generateTileDeck();
                this.layout = this.generateTurtleLayout();

                this.boardContainer = document.getElementById('board-container');
                this.scoreDisplay = document.getElementById('score-display');
                this.remainingDisplay = document.getElementById('remaining-display');
                this.messageOverlay = document.getElementById('message-overlay');
                this.messageTitle = document.getElementById('message-title');
                this.messageText = document.getElementById('message-text');

                // Bind buttons
                document.getElementById('btn-new-game').addEventListener('click', () => this.newGame());
                document.getElementById('btn-undo').addEventListener('click', () => this.undo());
                document.getElementById('btn-hint').addEventListener('click', () => this.hint());

                this.newGame();
            }

            generateTileDeck() {
                const deck = [];
                // Simple suits: 1-9 (4 of each)
                ['Dots', 'Bams', 'Chars'].forEach(suit => {
                    for (let i = 1; i <= 9; i++) {
                        for (let j = 0; j < 4; j++) deck.push({ type: suit, value: i });
                    }
                });
                // Winds: East, South, West, North (4 of each)
                ['East', 'South', 'West', 'North'].forEach(val => {
                    for (let j = 0; j < 4; j++) deck.push({ type: 'Winds', value: val });
                });
                // Dragons: Red, Green, White (4 of each)
                ['Red', 'Green', 'White'].forEach(val => {
                    for (let j = 0; j < 4; j++) deck.push({ type: 'Dragons', value: val });
                });
                // Flowers: 1-4 (1 of each)
                for (let i = 1; i <= 4; i++) deck.push({ type: 'Flowers', value: i });
                // Seasons: 1-4 (1 of each)
                for (let i = 1; i <= 4; i++) deck.push({ type: 'Seasons', value: i });

                return deck;
            }

            getSymbol(tile) {
                // Unicode mapping
                // U+1F000 is Mahjong Tile East Wind
                // Base offsets
                const bases = {
                    'Winds': 0x1F000, // East, South, West, North -> 0, 1, 2, 3
                    'Dragons': 0x1F004, // Red, Green, White -> 0, 1, 2
                    'Chars': 0x1F007, // 1-9 -> 0..8
                    'Bams': 0x1F010, // 1-9 -> 0..8
                    'Dots': 0x1F019, // 1-9 -> 0..8
                    'Flowers': 0x1F022, // 1-4 -> 0..3
                    'Seasons': 0x1F026 // 1-4 -> 0..3
                };

                let code = 0;
                if (tile.type === 'Winds') {
                    const map = { 'East': 0, 'South': 1, 'West': 2, 'North': 3 };
                    code = bases['Winds'] + map[tile.value];
                } else if (tile.type === 'Dragons') {
                    const map = { 'Red': 0, 'Green': 1, 'White': 2 };
                    code = bases['Dragons'] + map[tile.value];
                } else if (tile.type === 'Chars' || tile.type === 'Bams' || tile.type === 'Dots') {
                    code = bases[tile.type] + (tile.value - 1);
                } else if (tile.type === 'Flowers' || tile.type === 'Seasons') {
                    code = bases[tile.type] + (tile.value - 1);
                }

                return String.fromCodePoint(code);
            }

            generateTurtleLayout() {
                // Turtle layout coordinates (x, y, z)
                // Grid units: 1 tile width = 2 units, 1 tile height = 2 units (to allow half steps)
                // Standard tile is roughly 2x2 in this grid.
                // x increases right, y increases down, z increases up.

                const layout = [];

                // Level 0 (Bottom) - 87 tiles
                // Main block: 12 wide (from x=2 to x=24 step 2), 7 high (y=2 to y=14 step 2) -> 12*7 = 84? No.
                // Let's define rows.
                // Row 0: tiles at x=2,4,6...24?
                // Standard Turtle:
                // 14, 12, 10, 8, 10, 12, 14 pattern?
                // Let's use a simplified explicit list for a "Pyramid" if Turtle is too hard to hardcode perfectly.
                // But user asked for Mahjong, which implies Turtle.

                // Let's try to build it layer by layer.
                // Center is roughly x=14, y=8

                // Layer 0
                // Top and Bottom rows (2 tiles each): (x=6,8,20,22? No)
                // Let's do a solid rectangle 12x8 minus corners.
                // Rows:
                // y=0: x=2,4,6,8,10,12,14,16,18,20,22,24 (12 tiles)
                // ...

                // Let's use a predefined map for Turtle.
                // Format: [x, y, z] (x,y in half-tile units)

                const addRect = (x1, x2, y1, y2, z) => {
                    for (let y = y1; y <= y2; y += 2) {
                        for (let x = x1; x <= x2; x += 2) {
                            layout.push({ x, y, z });
                        }
                    }
                };

                // Layer 0 (87 tiles)
                // Main body
                addRect(2, 24, 2, 14, 0); // 12 * 7 = 84 tiles
                // Add "ears" (left/right extensions)
                // Left: x=-2, y=8 (center y)
                layout.push({ x: -2, y: 7, z: 0 }); // Left ear 1
                layout.push({ x: -2, y: 9, z: 0 }); // Left ear 2? No usually just one or two.
                // Standard turtle has 2 tiles on far left, 2 on far right.
                // Let's stick to the 144 count.
                // Current: 84. Need 3 more for 87?
                // Let's adjust:
                // Top row (y=0): x=12, 14 (2 tiles)
                // Bottom row (y=16): x=12, 14 (2 tiles)
                // Left side (x=0): y=6, 8, 10 (3 tiles)
                // Right side (x=26): y=6, 8, 10 (3 tiles)
                // This is getting complicated.

                // Alternative: Simple Pyramid Layout (easier to code, still 144)
                // 8x10 base = 80
                // 6x8 = 48 -> 128
                // 4x6 = 24 -> 152 (too many)

                // Let's try to replicate Turtle accurately enough.
                // Layer 1 (0):
                // Row 1: x=2..24 (12 tiles)
                // Row 2: x=4..22 (10 tiles) -- wait, standard is rectangular with sticky out bits.

                // Let's just define a nice 144 tile layout.
                // Layer 0: 12x8 grid (96 tiles). Remove 4 corners (92). Remove 2 from center? (90).
                // Let's do: 10x8 = 80.
                // Layer 1: 6x6 = 36. (Total 116)
                // Layer 2: 4x4 = 16. (Total 132)
                // Layer 3: 2x2 = 4. (Total 136)
                // Layer 4: 1 tile on top. (Total 137)
                // Need 7 more.
                // Add 2 on left, 2 on right (ears) -> 141.
                // Add 3 more somewhere?

                // Let's reset and do a clean 144 construction.
                // Layer 0: 8x12 grid (x=0..22, y=0..14). 
                // Let's do 6 rows of 12 = 72.
                // Layer 1: 4 rows of 8 = 32. (104)
                // Layer 2: 2 rows of 4 = 8. (112)
                // This is too small.

                // Let's use the standard Turtle counts: 87, 36, 16, 4, 1. Total 144.
                // Layer 0 (87):
                //   Rows 1-7 (y=0 to 12).
                //   Row 1 (y=0): x=2,4,6,8,10,12,14,16,18,20,22,24 (12 tiles)
                //   Row 2 (y=2): x=4..22 (10 tiles) -> No, standard is rectangular.
                //   Let's do:
                //   Row 0: x=2..24 (12)
                //   Row 1: x=2..24 (12)
                //   Row 2: x=2..24 (12)
                //   Row 3: x=-2..28 (16) -- The long middle row with ears?
                //   Row 4: x=2..24 (12)
                //   Row 5: x=2..24 (12)
                //   Row 6: x=2..24 (12)
                //   Total: 12*6 + 16 = 88. Close enough to 87. Remove one?
                //   Let's remove x=24 from Row 6. -> 87.

                // Layer 1 (36):
                //   6x6 square in center.
                //   Center of layer 0 is approx x=13, y=6.
                //   6x6 grid: x=8..18, y=2..12?
                //   Let's do x=8,10,12,14,16,18 (6) and y=2,4,6,8,10,12 (6). Total 36.

                // Layer 2 (16):
                //   4x4 square.
                //   x=10,12,14,16. y=4,6,8,10. Total 16.

                // Layer 3 (4):
                //   2x2 square.
                //   x=12,14. y=6,8. Total 4.

                // Layer 4 (1):
                //   Center. x=13, y=7. (Half step to center it perfectly on 2x2)
                //   Wait, my grid is steps of 2.
                //   x=13 is valid (half overlap).

                const l = [];
                // Layer 0
                const rowY = [0, 2, 4, 6, 8, 10, 12];
                rowY.forEach((y, idx) => {
                    if (idx === 3) { // Middle row (widest)
                        for (let x = -2; x <= 28; x += 2) l.push({ x, y, z: 0 }); // 16 tiles
                    } else {
                        for (let x = 2; x <= 24; x += 2) l.push({ x, y, z: 0 }); // 12 tiles
                    }
                });
                // That's 16 + 12*6 = 88. Remove last one to get 87? Or just keep 88.
                // If I have 144 tiles total, I need exactly 144 positions.
                // 88 + 36 + 16 + 4 + 1 = 145.
                // Remove one from Layer 0. Let's remove x=24, y=12 (bottom right corner).
                l.pop();

                // Layer 1 (36)
                for (let y = 2; y <= 12; y += 2) {
                    for (let x = 8; x <= 18; x += 2) l.push({ x, y, z: 1 });
                }

                // Layer 2 (16)
                for (let y = 4; y <= 10; y += 2) {
                    for (let x = 10; x <= 16; x += 2) l.push({ x, y, z: 2 });
                }

                // Layer 3 (4)
                for (let y = 6; y <= 8; y += 2) {
                    for (let x = 12; x <= 14; x += 2) l.push({ x, y, z: 3 });
                }

                // Layer 4 (1)
                l.push({ x: 13, y: 7, z: 4 });

                return l;
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            newGame() {
                this.history = [];
                this.selectedTile = null;
                this.messageOverlay.classList.remove('visible');
                this.boardContainer.innerHTML = '';

                // Shuffle deck
                this.shuffle(this.tileTypes);

                // Create tile objects
                this.tiles = this.layout.map((pos, index) => {
                    if (index >= this.tileTypes.length) return null; // Should not happen if counts match
                    const type = this.tileTypes[index];
                    return {
                        id: index,
                        ...pos,
                        ...type,
                        element: null,
                        removed: false
                    };
                }).filter(t => t !== null);

                // Render
                this.renderBoard();
                this.updateStatus();
                this.checkForMoves();
            }

            renderBoard() {
                // Find board bounds to center it
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                this.tiles.forEach(t => {
                    minX = Math.min(minX, t.x);
                    maxX = Math.max(maxX, t.x);
                    minY = Math.min(minY, t.y);
                    maxY = Math.max(maxY, t.y);
                });

                // Calculate size
                const tileW = 50; // matches css
                const tileH = 70;
                const unitX = tileW / 2;
                const unitY = tileH / 2;

                const boardW = (maxX - minX + 2) * unitX;
                const boardH = (maxY - minY + 2) * unitY;

                this.boardContainer.style.width = `${boardW}px`;
                this.boardContainer.style.height = `${boardH}px`;

                this.tiles.forEach(tile => {
                    const el = document.createElement('div');
                    el.className = `tile suit-${tile.type.toLowerCase()}`;
                    el.dataset.id = tile.id;
                    el.dataset.value = tile.value;
                    el.textContent = this.getSymbol(tile);

                    // Position
                    // x,y are in half-tile units.
                    // We need to offset by minX, minY to start at 0,0
                    const left = (tile.x - minX) * unitX;
                    const top = (tile.y - minY) * unitY;
                    const zIndex = tile.z * 10 + tile.x + tile.y; // Simple z-index sort

                    el.style.left = `${left}px`;
                    el.style.top = `${top}px`;
                    el.style.zIndex = zIndex;

                    // 3D lift
                    el.style.transform = `translateZ(${tile.z * 10}px)`;

                    el.onclick = (e) => {
                        e.stopPropagation();
                        this.handleTileClick(tile);
                    };

                    tile.element = el;
                    this.boardContainer.appendChild(el);
                });

                this.updateBlockedStatus();
            }

            isBlocked(tile) {
                if (tile.removed) return true;

                let blockedByTop = false;
                let blockedLeft = false;
                let blockedRight = false;

                for (const other of this.tiles) {
                    if (other.removed || other.id === tile.id) continue;

                    // Check Top: z is tile.z + 1
                    // Overlap condition: abs(x - other.x) < 2 && abs(y - other.y) < 2
                    if (other.z === tile.z + 1) {
                        if (Math.abs(other.x - tile.x) < 2 && Math.abs(other.y - tile.y) < 2) {
                            blockedByTop = true;
                        }
                    }

                    // Check Sides: z is same
                    // Left: other.x = tile.x - 2, abs(y overlap) < 2
                    // Right: other.x = tile.x + 2, abs(y overlap) < 2
                    if (other.z === tile.z) {
                        if (Math.abs(other.y - tile.y) < 2) {
                            if (other.x === tile.x - 2) blockedLeft = true;
                            if (other.x === tile.x + 2) blockedRight = true;
                        }
                    }
                }

                return blockedByTop || (blockedLeft && blockedRight);
            }

            updateBlockedStatus() {
                this.tiles.forEach(tile => {
                    if (tile.removed) return;
                    const blocked = this.isBlocked(tile);
                    if (blocked) {
                        tile.element.classList.add('blocked');
                    } else {
                        tile.element.classList.remove('blocked');
                    }
                });
            }

            handleTileClick(tile) {
                if (tile.removed || this.isBlocked(tile)) return;

                if (this.selectedTile === tile) {
                    // Deselect
                    this.selectedTile = null;
                    tile.element.classList.remove('selected');
                } else {
                    if (this.selectedTile) {
                        // Try match
                        if (this.isMatch(this.selectedTile, tile)) {
                            this.removeTiles(this.selectedTile, tile);
                            this.selectedTile = null;
                        } else {
                            // Switch selection
                            this.selectedTile.element.classList.remove('selected');
                            this.selectedTile = tile;
                            tile.element.classList.add('selected');
                        }
                    } else {
                        // Select
                        this.selectedTile = tile;
                        tile.element.classList.add('selected');
                    }
                }
            }

            isMatch(t1, t2) {
                if (t1.type !== t2.type) return false;

                // Flowers and Seasons match any in their suit
                if (t1.type === 'Flowers') return true;
                if (t1.type === 'Seasons') return true;

                // Others must match value
                return t1.value === t2.value;
            }

            removeTiles(t1, t2) {
                t1.removed = true;
                t2.removed = true;
                t1.element.style.display = 'none';
                t2.element.style.display = 'none';
                t1.element.classList.remove('selected');

                this.history.push([t1, t2]);
                this.updateBlockedStatus();
                this.updateStatus();

                // Clear hints
                document.querySelectorAll('.hint').forEach(el => el.classList.remove('hint'));

                this.checkForMoves();
            }

            undo() {
                if (this.history.length === 0) return;

                const pair = this.history.pop();
                pair.forEach(t => {
                    t.removed = false;
                    t.element.style.display = 'flex';
                });

                this.selectedTile = null;
                document.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));

                this.updateBlockedStatus();
                this.updateStatus();
                this.messageOverlay.classList.remove('visible');
            }

            hint() {
                // Find a valid move
                const freeTiles = this.tiles.filter(t => !t.removed && !this.isBlocked(t));

                for (let i = 0; i < freeTiles.length; i++) {
                    for (let j = i + 1; j < freeTiles.length; j++) {
                        if (this.isMatch(freeTiles[i], freeTiles[j])) {
                            // Highlight these two
                            freeTiles[i].element.classList.add('hint');
                            freeTiles[j].element.classList.add('hint');

                            // Remove hint after 2s
                            setTimeout(() => {
                                freeTiles[i].element.classList.remove('hint');
                                freeTiles[j].element.classList.remove('hint');
                            }, 2000);
                            return;
                        }
                    }
                }
                alert("No moves available! Try Undo or New Game.");
            }

            checkForMoves() {
                const remaining = this.tiles.filter(t => !t.removed).length;
                if (remaining === 0) {
                    this.showWin();
                    return;
                }

                const freeTiles = this.tiles.filter(t => !t.removed && !this.isBlocked(t));
                let hasMove = false;

                for (let i = 0; i < freeTiles.length; i++) {
                    for (let j = i + 1; j < freeTiles.length; j++) {
                        if (this.isMatch(freeTiles[i], freeTiles[j])) {
                            hasMove = true;
                            break;
                        }
                    }
                    if (hasMove) break;
                }

                if (!hasMove) {
                    this.messageTitle.textContent = "No More Moves";
                    this.messageText.textContent = "There are no matching pairs available.";
                    this.messageOverlay.classList.add('visible');
                }
            }

            updateStatus() {
                const remaining = this.tiles.filter(t => !t.removed).length;
                this.remainingDisplay.textContent = `Tiles: ${remaining}`;
                this.scoreDisplay.textContent = `Pairs: ${this.history.length}`;
            }

            showWin() {
                this.messageTitle.textContent = "You Win!";
                this.messageText.textContent = "Congratulations! You cleared the board.";
                this.messageOverlay.classList.add('visible');
            }
        }

        // Start game
        const game = new MahjongGame();

    </script>
</body>

</html>